import { useCallback, useMemo, useState } from 'react';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { alpha } from '@mui/system/colorManipulator';
import Box from '@mui/material/Box';
import Stack from '@mui/material/Stack';
import Tab from '@mui/material/Tab';
import Tabs from '@mui/material/Tabs';
import Typography from '@mui/material/Typography';
import { codeStyle } from 'src/utils/code-style';
const samples = [
  // {
  //   lang: 'jsx',
  //   label: 'ethereum - sepolia',
  //   icon: '/assets/logos/stack-logos-008.png',
  //   code: `"SecureCrossChainTransferAndLexOracle Smart Contract Deployed on SEPOLIA testnet.\\n\\nTRANSACTION: https://sepolia.etherscan.io/tx/0xb4ae9765eb20e8711ba921ff831b8e420441f59d460d2ebc2884096557103259\\nSMART-CONTRACT: https://sepolia.etherscan.io/address/0x4088f46F3420A441eDb3a8800A1894eC4CA28A3a\\n\\n"`
  // },
  // {
  //   lang: 'bash',
  //   label: 'Bash Commands',
  //   icon: '/assets/logos/bash.png',
  //   code: `"# Getting Started\\n\\n# Use Node Version Manager\\n$ nvm use lts/gallium\\n\\n# Install the project dependencies.\\n$ npm install\\n# or\\n$ yarn\\n\\n# Run the development server:\\n$ npm run dev\\n# or\\n$ yarn dev\\n\\nOpen http://localhost:3000 in a browser to view the application."`
  // },
  {
    lang: 'sol',
    label: 'SecureCrossChain...Oracle.sol',
    icon: '/assets/logos/stack-logos-009w.png',
    code: `"/// SPDX-License-Identifier: AGPL-3.0-or-later and Custom-Commercial-License\\npragma solidity ^0.8.20;\\npragma experimental ABIEncoderV2;\\n\\n// Copyright (c) 2023 Scott Stevenson, J.D. and Web3 Legal Engineering\\n/* Dual-licensed under the GNU Affero General Public License AGPL-3.0-or-later \\n * (https://spdx.org/licenses/AGPL-3.0-or-later.html)and a Commercial License. \\n * Contact Scott Stevenson at scott@onelaw.us or @tenfinney for commercial licensing inquiries. \\n */ \\n \\nimport '@chainlink/contracts/src/v0.8/ChainlinkClient.sol'; \\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol'; \\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol'; \\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol'; \\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol'; \\n \\ncontract SecureCrossChainTransferAndLexOracle is \\n    ChainlinkClient, \\n    ReentrancyGuard \\n{ \\n    using Chainlink for Chainlink.Request; \\n    using SafeMath for uint256; \\n \\n    // s ----------------------------- STATE VARIABLES ----------------------------------------------- \\n    Chain public nativeChain; \\n    IERC20 public token; \\n    string public apiKey; \\n    string public endpoint; \\n    string public caseData; \\n    string public caseName; \\n    string public caselawApiEndpoint; \\n    string public test_parameter_1; \\n    string public test_parameter_2; \\n    address public oracle; \\n    address public owner; \\n    address public oracleNode; \\n    address public nativeTokenAddress; \\n    address public immutable ethereumNativeToken = \\n        0x0000000000000000000000000000000000000000; \\n    address public immutable polygonNativeToken = \\n        0x0000000000000000000000000000000000001010; \\n    address public immutable avalancheNativeToken = \\n        0x93567d6B6553bDe2b652FB7F197a229b93813D3f; \\n    address public immutable ethereumOracle = \\n        0xDC530D9457755926550b59e8ECcdaE7624181557; \\n    address public immutable polygonOracle = \\n        0xd9FFdb71EbE7496cC440152d43986Aae0AB76665; \\n    address public immutable avalancheOracle = \\n        0x49ccd9ca821EfEab2b98c60dC60F518E765EDe9a; \\n    bytes32 public jobId; \\n    bytes32 public requestId; \\n    bytes32 private encryptedData; \\n    uint256 public fee; \\n    uint256 public transactionCounter; \\n    enum Chain { \\n        Ethereum, \\n        Polygon, \\n        Avalanche, \\n        Sepolia, \\n        Mumbai, \\n        Fuji \\n    } \\n \\n    mapping(Chain => address) public nativeTokenAddresses; \\n    mapping(Chain => address) public oracleAddresses; \\n    mapping(Chain => bytes32) public jobIds; \\n    mapping(address => Chain) public reverseNativeTokenMapping; \\n    mapping(address => address) public nextChain; \\n    mapping(address => string) public messages; \\n    mapping(address => uint256) public balances; \\n    mapping(address => bool) public isTokenAdded; \\n    mapping(bytes32 => address) public requestIdToRequester; \\n    mapping(uint256 => uint256) private transactionTokenAmounts; \\n \\n    // c ----------------------------- CONSTRUCTOR --------------------------------------------------- \\n    constructor() { \\n        if (block.chainid == 1) { \\n            nativeChain = Chain.Ethereum; \\n        } else if (block.chainid == 137) { \\n            nativeChain = Chain.Polygon; \\n        } else if (block.chainid == 43114) { \\n            nativeChain = Chain.Avalanche; \\n        } \\n        owner = msg.sender; \\n        jobId = '7223acbd01654282865b678924126013'; // set an arbitrary jobId \\n        apiKey = 'encrypted_apiKey_8675309'; \\n        endpoint = 'https://api.case.law/v1/cases/?page_size=10&ordering=relevance'; \\n        fee = 10000000000000000; // Actual fee 10000000000000000 0.01 LINK) \\n        nativeTokenAddresses[ \\n            Chain.Ethereum \\n        ] = 0x0000000000000000000000000000000000000000; \\n        nativeTokenAddresses[ \\n            Chain.Polygon \\n        ] = 0x0000000000000000000000000000000000001010; \\n        nativeTokenAddresses[ \\n            Chain.Avalanche \\n        ] = 0x93567d6B6553bDe2b652FB7F197a229b93813D3f; \\n        caselawApiEndpoint = 'https://api.case.law/v1/cases/?page_size=10&ordering=relevance'; \\n        test_parameter_1 = 'Instructions for an off-chain API call for test_parameter_1.'; \\n        test_parameter_2 = 'Instructions for an off-chain API call for test_parameter_2.'; \\n    } \\n \\n    // m ----------------------------- PERMISSIONS --------------------------------------------------- \\n    modifier onlyOwner() { \\n        require(msg.sender == owner, 'Only the owner can call this function'); \\n        _; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Function to transfer ownership of the contract \\n    function transferOwnership(address newOwner) external onlyOwner { \\n        require(newOwner != address(0), 'Invalid new owner'); \\n        emit OwnershipTransferred(owner, newOwner); \\n        owner = newOwner; \\n    } \\n \\n    // Event emitted when the contract ownership is transferred \\n    event OwnershipTransferred( \\n        address indexed previousOwner, \\n        address indexed newOwner \\n    ); \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getNativeChain() internal view returns (Chain) { \\n        if (block.chainid == 1) { \\n            return Chain.Ethereum; \\n        } else if (block.chainid == 137) { \\n            return Chain.Polygon; \\n        } else if (block.chainid == 43114) { \\n            return Chain.Avalanche; \\n        } \\n        // If none of the above conditions are met, return a default value \\n        return Chain.Ethereum; // You can replace Chain.Ethereum with an appropriate default value \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getNativeTokenAddress() public view returns (address) { \\n        return nativeTokenAddress; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getNativeTokenForChain( \\n        Chain chain \\n    ) internal view returns (address) { \\n        if (chain == Chain.Ethereum) { \\n            return ethereumNativeToken; \\n        } \\n        if (chain == Chain.Polygon) { \\n            return polygonNativeToken; \\n        } \\n        if (chain == Chain.Avalanche) { \\n            return avalancheNativeToken; \\n        } \\n        revert('Unsupported chain'); \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getNativeTokenAddress( \\n        Chain chain \\n    ) internal view returns (address) { \\n        if (chain == Chain.Polygon) { \\n            return polygonNativeToken; \\n        } else if (chain == Chain.Avalanche) { \\n            return avalancheNativeToken; \\n        } \\n        // Default to Ethereum \\n        return ethereumNativeToken; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getNativeTokenDetails( \\n        Chain chain \\n    ) external view returns (address, uint256) { \\n        // Returns details of a native token on a specific chain \\n        address chainNativeToken = getNativeTokenAddress(chain); \\n        // Replace this with specific token details retrieval logic \\n        uint256 balance = IERC20(chainNativeToken).balanceOf(address(this)); \\n        return (chainNativeToken, balance); \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function logCurrentNativeToken() external view returns (address) { \\n        address current = nativeTokenAddresses[Chain.Ethereum]; \\n        return current; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Get next transaction ID \\n    function getNextTransactionCounter() internal returns (uint256) { \\n        transactionCounter++; \\n        return transactionCounter; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Utility function to withdraw Link \\n    function withdrawLink() public onlywner { \\n        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress()); \\n        require( \\n            link.transfer(owner, link.balanceOf(address(this))), \\n            'Unable to transfer LINK to owner' \\n        ); \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Function to set encrypted data \\n    function setEncryptedData(bytes32 _data) public onlyOwner { \\n        encryptedData = _data; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Return encrypted data \\n    function getEncryptedData() public view onlyOwner returns (bytes32) { \\n        return encryptedData; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Decode encrypted data \\n    function decryptData( \\n        bytes32 decryptionKey \\n    ) public view onlyOwner returns (bytes32) { \\n        // Decrypt the data using the provided decryption key \\n        require(decryptionKey != bytes32(0), 'Invalid decryption key'); \\n        return xor(encryptedData, decryptionKey); // For demonstration purposes, use XOR as a simple decryption method \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Returns a bytes32 \\n    function xor(bytes32 a, bytes32 b) private pure returns (bytes32) { \\n        return a ^ b; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getNextChain(address userAddress) external view returns (Chain) { \\n        address userNextChain = nextChain[userAddress]; \\n        return reverseNativeTokenMapping[userNextChain]; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function updateOracleNode(address newOracleNode) public onlyOwner { \\n        oracleNode = newOracleNode; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function updateApiKey(string memory newApiKey) public onlyOwner { \\n        apiKey = newApiKey; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function updateEndpoint(string memory newEndpoint) public onlyOwner { \\n        endpoint = newEndpoint; \\n    } \\n \\n    // f ----------------------------- FUNCTION AND EVENTS ------------------------------------------- \\n    function getCurrentNativeToken() external view returns (address) { \\n        return nativeTokenAddresses[Chain.Ethereum]; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getContractBalance() external view returns (uint256) { \\n        return token.balanceOf(address(this)); \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function stringToBytes32( \\n        string memory source \\n    ) internal pure returns (bytes32 result) { \\n        bytes memory tempEmptyStringTest = bytes(source); \\n        if (tempEmptyStringTest.length == 0) { \\n            return 0x0; \\n        } \\n        assembly { \\n            result := mload(add(source, 32)) \\n        } \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function bytes32ToString( \\n        bytes32 _bytes32 \\n    ) internal pure returns (string memory) { \\n        uint8 i = 0; \\n        while (i < 32 && _bytes32[i] != 0) { \\n            i++; \\n        } \\n        bytes memory bytesArray = new bytes(i); \\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) { \\n            bytesArray[i] = _bytes32[i]; \\n        } \\n        return string(bytesArray); \\n    } \\n \\n    // x --------------------------------------------------------------------------------------------- \\n    // x ---------------------------- CROSS CHAIN MESSAGING ------------------------------------------ \\n    // x --------------------------------------------------------------------------------------------- \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    function setNextChain( \\n        address tokenAddress, \\n        Chain nextChainEnum \\n    ) external onlyOwner { \\n        // Validate token address \\n        require(tokenAddress != address(0), 'Invalid token address'); \\n        // Get native token for the chain \\n        address nextNativeToken = getNativeTokenForChain(nextChainEnum); \\n        // Set next chain mapping \\n        nextChain[tokenAddress] = nextNativeToken; \\n        // Set reverse mapping \\n        reverseNativeTokenMapping[nextNativeToken] = nextChainEnum; \\n        // Emit event \\n        emit NextChainSet(tokenAddress, nextNativeToken); \\n    } \\n \\n    event NextChainSet( \\n        address indexed tokenAddress, \\n        address indexed nativeToken \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENTS ------------------------------------------- \\n    function depositTokens(uint256 amount) external onlyOwner nonReentrant { \\n        // Get native token address \\n        address currentNativeToken = nativeTokenAddresses[Chain.Ethereum]; \\n        // Validate token \\n        require(isTokenAdded[currentNativeToken], 'Invalid native token'); \\n        // Deposit tokens \\n        IERC20(currentNativeToken).transferFrom( \\n            msg.sender, \\n            address(this), \\n            amount \\n        ); \\n        // Emit events \\n        uint256 transactionId = getNextTransactionCounter(); \\n        emit TokenDepositInitiated( \\n            msg.sender, \\n            currentNativeToken, \\n            amount, \\n            transactionId \\n        ); \\n        emit TransactionQueued(msg.sender, transactionId); \\n        emit TokenDeposited( \\n            msg.sender, \\n            currentNativeToken, \\n            amount, \\n            transactionId \\n        ); \\n    } \\n \\n    // Event emitted when a token deposit is initiated \\n    event TokenDepositInitiated( \\n        address indexed user, \\n        address indexed nativeToken, \\n        uint256 amount, \\n        uint256 transactionId \\n    ); \\n    // Event emitted when a token is deposited into the contract \\n    event TokenDeposited( \\n        address indexed user, \\n        address indexed nativeToken, \\n        uint256 amount, \\n        uint256 transactionId \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENTS ----------------------------------------- \\n    function withdrawTokens( \\n        address userAddress, \\n        uint256 amount \\n    ) external onlyOwner nonReentrant { \\n        // Additional security: Ensure the user address is valid \\n        require(userAddress != address(0), 'Invalid user address'); \\n        // Additional security: Ensure the native token is valid \\n        require( \\n            isTokenAdded[nativeTokenAddresses[Chain.Ethereum]], \\n            'Invalid native token' \\n        ); \\n \\n        // Withdraw tokens to the owner (Fictional Data, replace with actual logic) \\n        IERC20(nativeTokenAddresses[Chain.Ethereum]).transfer(owner, amount); \\n        // Increment and store the transactionId \\n        uint256 transactionId = getNextTransactionCounter(); \\n        // Emit TokenWithdrawalInitiated event \\n        emit TokenWithdrawalInitiated( \\n            owner, \\n            nativeTokenAddresses[Chain.Ethereum], \\n            amount, \\n            transactionId \\n        ); \\n        // Emit TransactionQueued event \\n        emit TransactionQueued(owner, transactionId); \\n    } \\n \\n    // Event emitted when a token withdrawal is initiated \\n    event TokenWithdrawalInitiated( \\n        address indexed user, \\n        address indexed nativeToken, \\n        uint256 amount, \\n        uint256 transactionId \\n    ); \\n    // Event emitted when there is a queued transaction \\n    event TransactionQueued( \\n        address indexed user, \\n        uint256 indexed transactionId \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Transfer tokens to another chain (Chain B) \\n    function transferTokensToOtherChain( \\n        address destinationChainContract, \\n        address tokenAddress, \\n        uint256 amount \\n    ) public onlyOwner { \\n        // Add security checks if needed \\n        // Implement token transfer logic specific to CCIP network \\n        // Example: Transfer tokens to the destination chain's contract \\n        IERC20(tokenAddress).transfer(destinationChainContract, amount); \\n        // Emit an event for transparency \\n        emit TokensTransferredToOtherChain( \\n            owner, \\n            destinationChainContract, \\n            tokenAddress, \\n            amount \\n        ); \\n    } \\n \\n    // Event emitted when tokens are transferred to another chain \\n    event TokensTransferredToOtherChain( \\n        address indexed sender, \\n        address indexed destinationChainContract, \\n        address indexed tokenAddress, \\n        uint256 amount \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    function sendMessage( \\n        Chain destinationChain, \\n        string calldata message, \\n        uint256 tokenAmount \\n    ) internal { \\n        // Sending messages logic for the specified destinationChain \\n        // Use Chainlink or other suitable use case method \\n        // For demonstration purposes simple logging used. \\n        emit MessageSent(destinationChain, message, tokenAmount); \\n    } \\n \\n    // Event emitted when a message is sent to another chain \\n    event MessageSent( \\n        Chain indexed destinationChain, \\n        string message, \\n        uint256 tokenAmount \\n    ); \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Send a cross-chain message to another chain \\n    function sendMessageToOtherChain( \\n        address destinationChainContract, \\n        string memory message \\n    ) public onlyOwner { \\n        // Add security checks if needed \\n        require( \\n            destinationChainContract != address(0), \\n            'Invalid destination chain contract address' \\n        ); \\n        require(bytes(message).length > 0, 'Empty message'); \\n        // Implement message passing logic specific to CCIP network \\n        // Use Chainlink oracles to transmit the message \\n        Chainlink.Request memory req = buildChainlinkRequest( \\n            jobIds[Chain.Polygon], \\n            address(this), \\n            this.fulfill.selector \\n        ); \\n        req.add('message', message); \\n        req.addUint('chainId', uint256(Chain.Polygon)); // Include the destination chain ID \\n        sendChainlinkRequestTo(oracleAddresses[Chain.Polygon], req, fee); \\n        // Emit an event for transparency \\n        emit MessageSentToOtherChain(owner, destinationChainContract, message); \\n    } \\n \\n    // Event emitted when a message is sent to another chain \\n    event MessageSentToOtherChain( \\n        address indexed sender, \\n        address indexed destinationChainContract, \\n        string message \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Placeholder function for processing CCIP messages - replace with actual logic \\n    function processCCIPMessage(string memory message) internal { \\n        // Replace this with the actual logic for processing the CCIP messages \\n        // Store the message or trigger some other action. \\n        // Emit an event to indicate that a CCIP message has been processed \\n        emit CCIPMessageProcessed(msg.sender, message); \\n    } \\n \\n    // Event emitted when a CCIP message is processed locally \\n    event CCIPMessageProcessed(address indexed sender, string message); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    function receiveMessageFromOtherChain(string memory message) public { \\n        // Implement logic to handle incoming messages from other chains \\n        require(bytes(message).length > 0, 'Empty message'); \\n        // Add specific logic here based on the incoming message \\n        // Store the message or trigger some other action. \\n        // Emit an event to indicate that a message has been received \\n        emit MessageReceivedFromOtherChain(msg.sender, message); \\n    } \\n \\n    // Event emitted when a message is received from another chain \\n    event MessageReceivedFromOtherChain(address indexed sender, string message); \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getMessage( \\n        address contractAddress \\n    ) public view returns (string memory) { \\n        return messages[contractAddress]; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Function to extract token amount from the message \\n    function getTokenAmountFromMessage( \\n        string memory /*_message*/ \\n    ) internal pure returns (uint256) { \\n        // Add token amount extraction logic from the message \\n        return 0; \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getTransactionStatus( \\n        uint256 transactionId \\n    ) external view returns (string memory) { \\n        // Returns the status of a transaction (Queued, Processed, Failed, or Invalid) \\n        if (transactionId < transactionCounter) { \\n            // Success criteria - replace with actual logic \\n            bool isTransactionSuccessful = checkSuccessCriteria(transactionId); \\n            return isTransactionSuccessful ? 'Processed' : 'Failed'; \\n        } else if (transactionId == transactionCounter) { \\n            return 'Queued'; \\n        } else { \\n            return 'Invalid'; \\n        } \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function getTransactionDetails( \\n        uint256 transactionId \\n    ) external view returns (address, string memory, uint256) { \\n        // Returns details of a transaction \\n        require(transactionId < transactionCounter, 'Invalid transaction ID'); \\n        // Replace this with your specific transaction details retrieval logic \\n        address user = owner; \\n        string memory message = messages[nextChain[address(this)]]; \\n        // Replace the next line with the actual token amount retrieval logic \\n        uint256 tokenAmount = transactionTokenAmounts[transactionId]; \\n        return (user, message, tokenAmount); \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    function checkSuccessCriteria( \\n        uint256 transactionId \\n    ) internal pure returns (bool) { \\n        return transactionId % 2 == 0; \\n    } \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    function addToken(address tokenAddress) external onlyOwner { \\n        // Additional security: Ensure the token has not been added before \\n        require(!isTokenAdded[tokenAddress], 'Token already added'); \\n        // Additional security: Ensure the token is a valid ERC20 token \\n        uint256 tokenBalance; \\n        try IERC20(tokenAddress).balanceOf(address(this)) returns ( \\n            uint256 balance \\n        ) { \\n            tokenBalance = balance; \\n        } catch { \\n            revert('Invalid ERC20 token'); \\n        } \\n        require(tokenBalance >= 0, 'Invalid ERC20 token'); \\n        // Mark the token as added \\n        isTokenAdded[tokenAddress] = true; \\n        // Emit TokenAdded event \\n        emit TokenAdded(tokenAddress); \\n    } \\n \\n    // Event emitted when a token is added to the contract \\n    event TokenAdded(address indexed nativeToken); \\n \\n    // x --------------------------------------------------------------------------------------------- \\n    // x ------------------------------- REQUESTING DATA --------------------------------------------- \\n    // x --------------------------------------------------------------------------------------------- \\n \\n    // f ----------------------------- FUNCTION AND EVENTS ------------------------------------------- \\n    // Sending a single message \\n    function sendSingleMessage(string memory _message) public onlyOwner { \\n        // Build Chainlink request \\n        Chainlink.Request memory req = buildChainlinkRequest( \\n            jobId, \\n            address(this), \\n            this.fulfill.selector \\n        ); \\n        req.add('message', _message); \\n        // Send Chainlink request to the oracle \\n        sendChainlinkRequestTo(oracle, req, fee); \\n        // Emit OracleRequestSent event \\n        uint256 transactionId = getNextTransactionCounter(); \\n        emit OracleRequestSent(owner, transactionId); \\n        emit TransactionQueued(owner, transactionId); \\n    } \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Send a message to another chain using Chainlink \\n    function sendMessage( \\n        Chain destinationChain, \\n        string calldata message \\n    ) external onlyOwner { \\n        // Additional security: Ensure the destination chain is valid \\n        require( \\n            destinationChain != Chain.Ethereum && \\n                destinationChain != Chain.Polygon && \\n                destinationChain != Chain.Avalanche, \\n            'Unsupported chain' \\n        ); \\n        require( \\n            destinationChain != Chain.Polygon, \\n            'Cannot send a message to Polygon' \\n        ); \\n        require( \\n            destinationChain != Chain.Avalanche, \\n            'Cannot send a message to Avalanche' \\n        ); \\n        // Send the message using Chainlink \\n        Chainlink.Request memory req = buildChainlinkRequest( \\n            jobIds[destinationChain], \\n            address(this), \\n            this.fulfill.selector \\n        ); \\n        req.add('message', message); \\n        sendChainlinkRequestTo(oracleAddresses[destinationChain], req, fee); \\n        // Emit OracleRequestSent event \\n        uint256 transactionId = getNextTransactionCounter(); \\n        emit OracleRequestSent(owner, transactionId); \\n        emit TransactionQueued(owner, transactionId); \\n    } \\n \\n    // Event emitted when an Oracle request is sent \\n    event OracleRequestSent( \\n        address indexed sender, \\n        uint256 indexed transactionId \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Send a message to another chain using Chainlink with token deposit \\n    function sendMessageComplex( \\n        Chain destinationChain, \\n        string calldata message, \\n        uint256 tokenAmount \\n    ) external onlyOwner { \\n        // Additional security: Ensure the destination chain is valid \\n        require( \\n            destinationChain != Chain.Ethereum, \\n            'Cannot send a message to Ethereum' \\n        ); \\n        require( \\n            destinationChain != Chain.Polygon, \\n            'Cannot send a message to Polygon' \\n        ); \\n        require( \\n            destinationChain != Chain.Avalanche, \\n            'Cannot send a message to Avalanche' \\n        ); \\n        // Get native token directly without redeclaration \\n        address nativeToken = nativeTokenAddresses[destinationChain]; \\n        // Validate token \\n        require(isTokenAdded[nativeToken], 'Invalid native token'); \\n        // Deposit tokens \\n        IERC20(nativeToken).transferFrom( \\n            msg.sender, \\n            address(this), \\n            tokenAmount \\n        ); \\n        // Send the message using Chainlink \\n        Chainlink.Request memory req = buildChainlinkRequest( \\n            jobIds[destinationChain], \\n            address(this), \\n            this.fulfillWithTokens.selector \\n        ); \\n        req.add('message', message); \\n        req.addUint('tokenAmount', tokenAmount); \\n        sendChainlinkRequestTo(oracleAddresses[destinationChain], req, fee); \\n        // Emit OracleRequestSent event \\n        uint256 transactionId = getNextTransactionCounter(); \\n        emit OracleRequestSent(owner, transactionId); \\n        emit TransactionQueued(owner, transactionId); \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Set Chainlink job ID and oracle address for a specific chain \\n    function setChainlinkJobAndOracle( \\n        Chain chain, \\n        bytes32 _jobId, \\n        address oracleAddress \\n    ) external onlyOwner { \\n        require(_jobId != bytes32(0), 'Invalid job ID'); \\n        require(oracleAddress != address(0), 'Invalid oracle address'); \\n        setOracle(chain, oracleAddress, bytes32ToString(_jobId)); \\n    } \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Callback function to handle the response from the Chainlink node \\n    function fulfill( \\n        bytes32 _requestId, \\n        string memory _message, \\n        uint256 version \\n    ) public recordChainlinkFulfillment(_requestId) { \\n        // Declare the variable message here \\n        string memory message; \\n        if (version == 1) { \\n            // Variation 1 logic \\n            messages[nextChain[msg.sender]] = _message; \\n        } else if (version == 2) { \\n            // Variation 2 logic \\n            // Additional security: Ensure the request is valid \\n            require( \\n                msg.sender == oracleAddresses[Chain.Polygon], \\n                'Invalid requestor' \\n            ); \\n            // Additional logic for Variation 2 \\n            // Replace the following line with the actual Variation 2 logic \\n            messages[nextChain[msg.sender]] = _message; \\n        } else if (version == 3) { \\n            // Variation 3 logic \\n            // Process and store the data as needed within the smart-contract \\n            caseData = processData(_message); \\n        } else if (version == 4 || version == 5) { \\n            // Variation 4 or 5 logic \\n            // Process and store the data as needed within the smart-contract \\n            // Variation 4 or 5 logic vvvv \\n            message = _message; \\n            // Emit an event with the result \\n            emit RequestFulfilled(_requestId, message); \\n            // Notify the requester (off-chain) that the data is ready \\n            address requester = requestIdToRequester[_requestId]; \\n            // Implement notification logic if needed \\n            // Additional logic for token transfer \\n            uint256 tokenAmount = getTokenAmountFromMessage(_message); // actual logic vvvv \\n            if (tokenAmount > 0) { \\n                // Transfer tokens to the requester \\n                token.transfer(requester, tokenAmount); \\n                emit TokensTransferred(requester, tokenAmount); \\n            } \\n        } else { \\n            // Handle unsupported version or throw an error \\n            revert('Unsupported version'); \\n        } \\n    } \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Placeholder function for processing data in Variation 3 \\n    function processData( \\n        string memory _data \\n    ) internal pure returns (string memory) { \\n        // Use data processing logic for Variation 3 \\n        return _data; \\n    } \\n \\n    event RequestFulfilled(bytes32 indexed requestId, string result); \\n \\n    // f ----------------------------- FUNCTION AND EVENTS ------------------------------------------- \\n    function processCCIPMessageAndTransfer( \\n        Chain destinationChain, \\n        string calldata message, \\n        uint256 tokenAmount \\n    ) external { \\n        // Validate token transfer \\n        require(tokenAmount > 0, 'Token amount must be greater than zero'); \\n        // Check if destinationChain is a valid enum value \\n        if (uint256(destinationChain) < uint256(Chain.Fuji)) { \\n            // Perform CCIP message transfer to the specified destination chain \\n            sendMessage(destinationChain, message, tokenAmount); \\n        } else { \\n            // Process CCIP message locally \\n            processCCIPMessage(message); \\n            // Transfer tokens to the contract \\n            token.transferFrom(msg.sender, address(this), tokenAmount); \\n            // Emit events for local CCIP message and token transfer \\n            emit CCIPMessageQueued(msg.sender, message); \\n            emit TokensTransferred(msg.sender, tokenAmount); \\n            emit MessageSent(destinationChain, message, tokenAmount); \\n            // Emit combined event \\n            emit CCIPMessageAndTransferQueued( \\n                msg.sender, \\n                destinationChain, \\n                message, \\n                tokenAmount \\n            ); \\n        } \\n    } \\n \\n    // Event emitted when message is queued \\n    event CCIPMessageQueued(address indexed sender, string ccipMessage); \\n    // Event emitted when tokens are transferred \\n    event TokensTransferred(address indexed sender, uint256 tokenAmount); \\n    // Event emitted when a CCIP message and token transfer are queued \\n    event CCIPMessageAndTransferQueued( \\n        address indexed sender, \\n        Chain indexed destinationChain, \\n        string ccipMessage, \\n        uint256 tokenAmount \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Function to Set Oracle \\n    function setOracle( \\n        Chain _chain, \\n        address _oracle, \\n        string memory _jobId \\n    ) internal { \\n        // Additional security: Ensure the oracle address is valid \\n        require(_oracle != address(0), 'Invalid oracle address'); \\n        // Initialize the oracle and job ID for each chain \\n        oracleAddresses[_chain] = _oracle; \\n        jobIds[_chain] = stringToBytes32(_jobId); \\n        // Emit OracleSet event \\n        emit OracleSet(_chain, _oracle, _jobId); \\n    } \\n \\n    // Event emitted when an oracle is set for a chain \\n    event OracleSet(Chain indexed chain, address indexed oracle, string jobId); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    function fulfillWithTokens( \\n        bytes32 _requestId, \\n        string memory _message, \\n        uint256 _tokenAmount \\n    ) public { \\n        // Ensure that the request ID is valid \\n        require(_requestId != bytes32(0), 'Invalid request ID'); \\n        // Validate the origin of the request (optional security check) \\n        // require(msg.sender == oracleAddresses[destinationChain], 'Invalid request sender'); \\n        // Process the received message data \\n        string memory processedData = processData(_message); \\n        // Placeholder logic: Process the received message and token amount \\n        // Use actual logic for handling the data \\n        processReceivedData(processedData, _tokenAmount); \\n        // Emit an event or perform other actions as needed \\n        emit FulfillmentWithTokens(_requestId, processedData, _tokenAmount); \\n    } \\n \\n    // Event emitted when fulfilled With Tokens \\n    event FulfillmentWithTokens( \\n        bytes32 indexed requestId, \\n        string message, \\n        uint256 tokenAmount \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Placeholder function for processing received data \\n    function processReceivedData( \\n        string memory _processedData, \\n        uint256 _tokenAmount \\n    ) internal { \\n        // Logic for handling the processed data \\n        // For updating state variables and/or interacting with other contracts \\n        // Simple processed data log example \\n        emit DataProcessed(_processedData, _tokenAmount); \\n    } \\n \\n    // Event emitted when data is processed in fulfillWithTokens \\n    event DataProcessed(string processedData, uint256 tokenAmount); \\n \\n    // f ----------------------------- FUNCTION ------------------------------------------------------ \\n    // Function to request data from the Caselaw API using Chainlink \\n    function requestCaseLawData( \\n        string memory caselawIdentifier, \\n        string memory customParameter1, \\n        string memory customParameter2 \\n    ) public payable { \\n        // Input Validation \\n        require(bytes(caselawIdentifier).length > 0, 'Empty caselawIdentifier'); \\n        require(bytes(customParameter1).length > 0, 'Empty customParameter1'); \\n        require(bytes(customParameter2).length > 0, 'Empty customParameter2'); \\n        // Access Control \\n        require(msg.sender == owner, 'Only the owner can make requests'); \\n        // Fee Validation \\n        require(msg.value >= fee, 'Insufficient funds for the request fee'); \\n        // Oracle Address Validation \\n        require( \\n            oracleAddresses[Chain.Ethereum] != address(0), \\n            'Invalid oracle address' \\n        ); \\n        // Build the Chainlink request \\n        Chainlink.Request memory req = buildChainlinkRequest( \\n            jobIds[Chain.Ethereum], \\n            address(this), \\n            this.fulfill.selector \\n        ); \\n        // Add parameters to the request \\n        req.add('caselawIdentifier', caselawIdentifier); \\n        req.add('apiKey', apiKey); \\n        req.add('caselawApiEndpoint', caselawApiEndpoint); \\n        req.add('customParameter1', customParameter1); \\n        req.add('customParameter2', customParameter2); \\n        // Send the Chainlink request to the oracle \\n        sendChainlinkRequestTo(oracleAddresses[Chain.Ethereum], req, fee); \\n    } \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Function to request data using Chainlink \\n    function requestData( \\n        string memory identifier, \\n        address _oracle \\n    ) external payable { \\n        // Input Validation \\n        require(bytes(identifier).length > 0, 'Empty identifier'); \\n        require(_oracle != address(0), 'Invalid oracle address'); \\n        // Access Control \\n        require(msg.sender == owner, 'Only the owner can make requests'); \\n        // Fee Validation \\n        require(msg.value >= fee, 'Insufficient funds for the request fee'); \\n        // Oracle Address Validation \\n        require( \\n            oracleAddresses[Chain.Polygon] != address(0), \\n            'Invalid oracle address' \\n        ); \\n \\n        // Build the Chainlink request \\n        Chainlink.Request memory req = buildChainlinkRequest( \\n            jobId, \\n            address(this), \\n            this.fulfill.selector \\n        ); \\n \\n        // Add common parameters to the request \\n        req.add('identifier', identifier); \\n        req.add('apiKey', apiKey); \\n        req.add('caselawApiEndpoint', caselawApiEndpoint); \\n        // Send the Chainlink request to the oracle \\n        sendChainlinkRequestTo(_oracle, req, fee); \\n        // Emit an event for transparency \\n        emit DataRequested(owner, identifier, _oracle); \\n    } \\n \\n    // Event emitted when case data is requested \\n    event DataRequested( \\n        address indexed requester, \\n        string identifier, \\n        address indexed oracle \\n    ); \\n \\n    // f ----------------------------- FUNCTION AND EVENT -------------------------------------------- \\n    // Function to request property data from the using Chainlink \\n    function requestPropertyData( \\n        string memory parcelNumber, \\n        address _oracle, \\n        uint256 timeout, \\n        string memory callbackFunction, \\n        uint256 gasLimit, \\n        string memory dataFormat, \\n        string memory encryptionKey, \\n        string memory callbackUrl, \\n        string memory customHeader, \\n        string memory dataFilter \\n    ) external payable { \\n        // Input Validation \\n        require(bytes(parcelNumber).length > 0, 'Empty parcelNumber'); \\n        require(_oracle != address(0), 'Invalid oracle address'); \\n        // Access Control \\n        require(msg.sender == owner, 'Only the owner can make requests'); \\n        // Fee Validation \\n        require(msg.value >= fee, 'Insufficient funds for the request fee'); \\n        // Oracle Address Validation \\n        require( \\n            oracleAddresses[Chain.Polygon] != address(0), \\n            'Invalid oracle address' \\n        ); \\n        // Build the Chainlink request \\n        Chainlink.Request memory req = buildChainlinkRequest( \\n            jobId, \\n            address(this), \\n            this.fulfill.selector \\n        ); \\n        // Add parameters to the request \\n        req.add('parcelNumber', parcelNumber); \\n        req.add('apiKey', apiKey); \\n        req.add('caselawApiEndpoint', caselawApiEndpoint); \\n        // Additional parameters \\n        req.addUint('timeout', timeout); \\n        req.add('callbackFunction', callbackFunction); \\n        req.addUint('gasLimit', gasLimit); \\n        req.add('dataFormat', dataFormat); \\n        req.add('encryptionKey', encryptionKey); \\n        req.add('callbackUrl', callbackUrl); \\n        req.add('customHeader', customHeader); \\n        req.add('dataFilter', dataFilter); \\n        // Send the Chainlink request to the oracle \\n        sendChainlinkRequestTo(_oracle, req, fee); \\n        // Emit an event for transparency \\n        emit CaseDataRequested(owner, parcelNumber, _oracle); \\n    } \\n \\n    // Event emitted when case data is requested \\n    event CaseDataRequested( \\n        address indexed requester, \\n        string caseIdentifier, \\n        address indexed oracle \\n    ); \\n} \\n"`
  },
  {
    lang: 'html',
    label: 'Button to contractABI.js',
    icon: '/assets/logos/stack-logos-006.png',
    code: `"Note: Copy and paste the following text after the --- to a new index.html file.\\nReplace all instances of the improper quotes (“) in the file to run locally. \\nFor example: the quotes around the <div class=“image-solo“> are the wrong type of\\n double quotes used for linting.\\nUse regular double quotes, or just follow the IPFS links to the files\\n in the button component.\\n\\n---\\n\\n<!DOCTYPE html>  \\n<html>  \\n<head>  \\n  <style>  \\n    body {  \\n      font-family: Arial, sans-serif;  \\n      margin: 4;  \\n      padding: 4;  \\n      background-color: #f2f2f2;  \\n    } \\n    .container { \\n      max-width: 1200px; \\n      margin: 1 auto; \\n      padding: 2em; \\n    }  \\n    button {  \\n      background-color: #375bd2;   \\n      border: none;  \\n      color: white;  \\n      padding: 15px 32px;  \\n      text-align: center;  \\n      text-decoration: none;  \\n      display: inline-block;  \\n      font-size: 16px;  \\n    }  \\n    .image-solo { \\n      max-width: 1200px; \\n      gap: 1em; \\n    } \\n  </style>    \\n</head>  \\n  \\n<body>  \\n  \\n \\n  <div class=“image-solo“> \\n    <img src=“https://freeweb3.infura-ipfs.io/ipfs/QmZKCayKEqSmkVVy3KSpKzwEPCCqHWxTEM18tTFraJBuvT“ alt=“Web3 LexAutomatico“></a> \\n    </div> \\n \\n<div class=“image-solo“> \\n    <!-- Replace with relevant Web3 images --> \\n    <a href='https://lexautomatico.com' target=“_blank“ rel=“noopener noreferrer“> \\n    <img src=“https://freeweb3.infura-ipfs.io/ipfs/QmfGgbaPNPxGujQb2tFSNjv8LRyD3SdMiiDgTZbxySKcR3“ alt=“Interchain Connector powered by Chainlink“></a> \\n \\n</div> \\n \\n \\n  <h2>View SecureCrossChainTransferAndLexOracle.sol</h2>   \\n  \\n  <button onclick=“location.href='https://freeweb3.infura-ipfs.io/ipfs/QmXpHpwPmgCn9b213HfbP38LF5oy9CE2xtrrE4pkwHEBm9';“ target=“_blank“>  \\n    View SecureCrossChainTransferAndLexOracle.sol file  \\n  </button>  \\n \\n \\n \\n  <h2>View ContractABI.js for use with SecureCrossChainTransferAndLexOracle.sol </h2>   \\n  \\n  <button onclick=“location.href='https://freeweb3.infura-ipfs.io/ipfs/QmRQer6po6bnCTkvS5fGbH3e75UGbpyfmSZEZFk6UEgwSe';“ target=“_blank“>  \\n    View Interchain Connector ABI file  \\n  </button>  \\n  \\n \\n  <h2>View SmartLaw Digital Artifacts and NFTs </h2>   \\n  \\n  <button onclick=“location.href='https://tokens.freeweb3.com';“ target=“_blank“>  \\n    View SmartLaw Digital Artifact and dNFTs \\n  </button>  \\n \\n  <div class=“container“> \\n        \\n \\n \\n</body>  \\n</html>  \\n"`
  },
  {
    lang: 'jsx',
    label: 'ApiResponse.jsx',
    icon: '/assets/logos/logo-javascript.svg',
    code: `"import React, { useState, useEffect } from 'react'; \\nimport Button from '@mui/material/Button';   \\n \\n// Import web3  \\nimport Web3 from web3; \\n \\n// Import contract ABI  \\nimport contractABI from './abi/contractABI'; \\n \\nconst contractAddress = '0x4088f46F3420A441eDb3a8800A1894eC4CA28A3a';  \\n \\nfunction App() { \\n \\n  const [web3, setWeb3] = useState(null); \\n  const [contract, setContract] = useState(null); \\n \\n  const [encryptedData, setEncryptedData] = useState(''); \\n  const [caseData, setCaseData] = useState(''); \\n \\n  useEffect(() => { \\n    const loadProvider = async () => { \\n      const provider = new Web3.providers.HttpProvider('HTTP://127.0.0.1:7545'); \\n \\n      const web3 = new Web3(provider); \\n      setWeb3(web3); \\n \\n      const contract = new web3.eth.Contract( \\n        contractABI, \\n        contractAddress   \\n      ); \\n      setContract(contract); \\n    }; \\n \\n    loadProvider(); \\n  }, []); \\n \\n  const getEncryptedData = async () => { \\n    const data = await contract.methods.getEncryptedData().call(); \\n    setEncryptedData(data); \\n  }; \\n \\n  const getCaseData = async () => {  \\n    const data = await contract.methods.caseData().call(); \\n    setCaseData(data); \\n  }; \\n   \\n  return ( \\n    <div> \\n      {web3 && contract && ( \\n        <> \\n          <Button variant='contained' onClick={getEncryptedData}> \\n            Get Encrypted Data  \\n          </Button> \\n          <div>Encrypted Data: {encryptedData}</div> \\n \\n          <Button variant='contained' onClick={getCaseData}> \\n            Get Case Data \\n          </Button> \\n          <div>Case Data: {caseData}</div> \\n        </> \\n      )} \\n    </div> \\n  ); \\n} \\n \\nexport default App; \\n"`
  }
];

export const HomeCodeSamples = () => {
const [lang, setLang] = useState(samples[0].lang);
const handleLangChange = useCallback((event, value) => {
setLang(value);
}, []);
const code = useMemo(() => {
return samples.find((sample) => sample.lang === lang)?.code.trim() || '';
}, [lang]);
return (
<Box
sx={{
display: 'flex',
flexDirection: 'column'
}}
>
<Stack
direction="row"
justifyContent="space-between"
spacing={2}
sx={{
backdropFilter: 'blur(6px)',
backgroundColor: (theme) => alpha(theme.palette.neutral[800], .95),
borderBottomColor: 'neutral.700',
borderBottomStyle: 'solid',
borderBottomWidth: 1,
borderTopLeftRadius: (theme) => theme.shape.borderRadius,
borderTopRightRadius: (theme) => theme.shape.borderRadius,
boxShadow: 24,
flex: '0 0 auto',
overflow: 'hidden',
px: 2
}}
>
<Stack
alignItems="center"
direction="row"
spacing={1}
sx={{
py: 2,
'& > div': {
backgroundColor: 'rgba(255, 255, 255, 0.16)',
borderRadius: '50%',
height: 10,
width: 10
}
}}
>
<div />
<div />
<div />
</Stack>
<Tabs
onChange={handleLangChange}
value={lang}
>
{samples.map((sample) => (
<Tab
key={sample.lang}
label={<Stack
alignItems="center"
direction="row"
spacing={1}
>
<Box
sx={{
borderRadius: '4px',
flex: '0 0 auto',
height: 20,
overflow: 'hidden',
width: 20,
'& img': {
width: '100%'
}
}}
>
<img src={sample.icon} />
</Box>
<Typography
sx={{ color: 'neutral.300' }}
variant="body2"
>
{sample.label}
</Typography>
</Stack>}
value={sample.lang}
/>
))}
</Tabs>
</Stack>
<Box
sx={{
backdropFilter: 'blur(6px)',
backgroundColor: (theme) => alpha(theme.palette.neutral[800], .9),
borderBottomLeftRadius: (theme) => theme.shape.borderRadius,
borderBottomRightRadius: (theme) => theme.shape.borderRadius,
flex: '1 1 auto',
overflow: 'hidden',
p: 2,
'& pre': {
background: 'none !important',
borderRadius: '0 !important',
fontSize: '12px !important',
height: '100%',
m: '0 !important',
// overflow: 'hidden !important',
overflow: '!important',
p: '0 !important'
},
'& code': {
fontSize: '12px !important'
}
}}
>
<SyntaxHighlighter
language={lang}
style={codeStyle}
>
{JSON.parse(code)}
</SyntaxHighlighter>
</Box>
</Box>
);
};
